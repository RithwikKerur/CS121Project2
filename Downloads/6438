http://www.ics.uci.edu/~kay/courses/h21/hw/hw9.html






Ninth Homework










ICS H21 • UC IRVINE • DAVID G. KAY • FALL 2009
Ninth Homework 
This assignment is due at the start of lab on
  Monday, November 23. 

(1)  We're not going to make completing
  the second midterm a part of the homework this time.  That doesn't mean
  you don't need to know how to do all the problems, though, because similar
  problems will turn up on the final exam (and, more importantly, because
  solving these problems represents the material you should be learning).
  Especially for those of you who received lower scores, it's important
  for you to determine for yourself that you can produce the answer to each
midterm question without referring to notes or an existing solution.
(2) Just as lists can contain other lists, vectors can contain lists, or even other vectors. That's how we can represent two-dimensional tables, still with constant-time access by row and column. Read this coverage of vectors containing vectors; it's also a good example of processing complex data structures layer by layer, which has been one of our main themes this quarter.
(3) Chapter 34 of the HtDP text begins
  the discussion of programs that have "state"—that is, programs
  that save values from one invocation to the next.  (This meaning of "state"
  is the same one we use when we talk about some system being in a "dormant
  state" or an "overloaded state."  A system's "state"
  is its status, and we often implement that with saved values which we can
  change with assignment statements.)  There aren't exercises in this chapter,
  but read it anyway.
 (4) Chapter 35 introduces set!.
  You should be able to do exercise 35.2.1. But please note that using set! means your program isn't following the functional style any more; assignment statments have their uses, but in Scheme programs those uses are very limited. You should know about them, but don't start writing all your Scheme programs in the imperative style.
 (5) Chapter 36 talks about the situations
  in which you'd choose to use "stateful" programs.  Note, though,
  that their examples can still be accomplished in a functional style, simply
  by keeping the state as part of the data (having a separate field in the
  traffic light, for example, to say what its current color is) and passing
  the whole object back and forth as usual.
 (6) Chapter 37 gives further examples
  of programs with state.  The rest of the book is interesting, too, but we
  just don't have the time for all of it.  You might note, though, the
  examples in Section 43.2; one use of mutation is to create data structures
  with cycles—that is, with interconnecting links.


Based in part on ICS H21assignments by David
G. Kay from Fall 2003; modified by David G. Kay, Fall 2004, Fall 2007, Fall 2008.

David G. Kay, kay@uci.edu 

Saturday, November 21, 2009 10:10 AM



