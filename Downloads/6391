http://www.ics.uci.edu/~kay/scheme/strings.scm
;; STRING PROCESSING CODE;; string-is-in?: string string -> boolean;; Return true if the first argument occurs anywhere in the second;; Examples returning true: (string-is-in? "do" "do re mi");; (string-is-in? "re" "do re mi") (string-is-in? "e m" "do re mi");; Examples returning false: (string-is-in "do re mi fa sol" "do re mi");; (string-is-in? "don't" "do re mi") (string-is-in? "remi" "do re mi")(define string-is-in?   (lambda (S1 S2)     (local ((define position (string-location S1 S2)))     (and (>= position 0) (< position (string-length S2))))));;Testing string-is-in?;; Examples returning true:(check-expect (string-is-in? "do" "do re mi") true)(check-expect (string-is-in? "re" "do re mi") true)(check-expect (string-is-in? "e m" "do re mi") true);; Examples returning false:(check-expect (string-is-in? "do re me fa sol" "do re mi") false)(check-expect (string-is-in? "don't" "do re mi") false)(check-expect (string-is-in? "remi" "do re mi") false)                   ;; string-location: string1 string2 -> number;; Returns the (zero-based) position in string2 where string1 first occurs;; (if string1 doesn't occur in string2, return the length of string2;;; if either string is empty, return -1);; Example: (string-location "is" "Mississippi") -> 1(define string-location  (lambda (S1 S2)   (cond     ((= 0 (string-length S1)) -1)     ((= 0 (string-length S2)) -1)     (else (string-loc-help (map char-downcase (string->list S1))                            (map char-downcase (string->list S2)))))))(define string-loc-help  (lambda (L1 L2)   (cond     ((empty? L2) 0)     ((initial-subsequence? L1 L2) 0)     (else (add1 (string-loc-help L1 (rest L2)))))));; Testing string-location(check-expect (string-location "is" "Mississippi") 1)(check-expect (string-location "Miss" "Mississippi") 0)(check-expect (string-location "Mistake" "Mississippi") (string-length "Mississippi") )(check-expect (string-location "p" "Mississippi") 8);; intial-subsequence?: list1 list2 -> boolean;; Return true if all the items of list1 occur as the first items of list2.(define initial-subsequence?  (lambda (L1 L2)   (cond     ((empty? L1) true)     ((empty? L2) false)     ((equal? (first L1) (first L2))      (initial-subsequence? (rest L1) (rest L2)))     (else false))));; Testing initial-subsequence?(check-expect (initial-subsequence? '(1 2 3) '(1 2 3 4 5)) true)(check-expect (initial-subsequence? '() '(1 2 3 4 5)) true)(check-expect (initial-subsequence? '(1 2 3) '(1 2 3)) true)(check-expect (initial-subsequence? '(1 2 3 4) '(1 2 3)) false)(check-expect (initial-subsequence? '(1) '()) false)(check-expect (initial-subsequence? '(1 2 3) '(1 2)) false)(check-expect (initial-subsequence? '(1) '(2 3 1)) false)(check-expect (initial-subsequence? '(1 2 4) '(1 2 3 4 5)) false)(check-expect (initial-subsequence? '(2 3) '(1 2 3 4 5)) false)